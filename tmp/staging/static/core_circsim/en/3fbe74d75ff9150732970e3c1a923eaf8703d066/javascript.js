/* >>>>>>>>>> BEGIN source/core.js */
/*globals CoreCircsim*/

CoreCircsim = SC.Object.create({

    /*
     * The following line would populate the records database (store) from the
     * fixtures found in frameworks/core_circsim/fixtures, which in turn were
     * generated by the build_circsim script. Use it in place of the emtpy
     * create() call it if this behavior is desired, such as for testing using a
     * static source of information for the simulation procedures. However, the
     * intended behavior is to load the procedure information dynamically (found
     * in core_loader.js).
     */
    // store: SC.Store.create().from(SC.Record.fixtures)
    store : SC.Store.create()

});

/* >>>>>>>>>> BEGIN source/core_api.js */
/*globals CoreCircsim*/

SC.mixin(CoreCircsim, {
  


});

/* >>>>>>>>>> BEGIN source/core_evaluations.js */
/*globals CoreCircsim*/

SC.mixin(CoreCircsim, {
  evaluateInitialVariableSelection: function(procedure, studentSelection) {
    var correctAnswer = procedure.get('initialVariable');
    if (correctAnswer === -1) return true;
    return studentSelection == correctAnswer ? true: false;
  },

  evaluateInitialVariableDirection: function(procedure, studentSelection) {
    var correctAnswer = procedure.get('initialVariableDirection');
    if (correctAnswer === -1) return true;
    return studentSelection == correctAnswer ? true: false;
  },

  evaluateRelationships: function(relationshipEvaluation, studentInput) {
    var keys, equationVars, errorKeys, message, num, comparisonValue, studentValues = [],
        evaluations = [];

      equationVars = relationshipEvaluation.equation;
      errorKeys = [[2,1,1], [2,1,0], [2,0,0], [2,0,1], [1,2,2], [1,2,0], [1,0,0], [1,0,2], [0,2,2], [0,2,0], [0,1,1], [0,1,0], [0,0,2], [0,0,1]];
      message = relationshipEvaluation.errorMessage;

      // Get student values at equation indices
      studentValues = [];
      equationVars.forEach(function(eq) {
        num = studentInput.objectAt(eq);
        studentValues.push(num);
      });
      
      errorKeys.forEach(function(k){
        if (SC.compare(k, studentValues)===0) {
          evaluations.push(message);
        }
      });
      
      return SC.compare(evaluations, []) === 0 ? false : message;
  
  },

  // This method returns an array populated by CoreCircsim.AnswerKey objects.
  evaluateProcedureSpecificErrors: function(procedure, columnNumber, studentInput) {
    var keyMatches = [];    
    // I think this shoudl be done in controller layer
    // I think the signature should be (answerKeys, studentInput)
    // This would be best because when I refactor the model layer, I will only be pulling out column specific answer keys anyway.  But that shouldn't matter here. 
    var answerKeys = procedure.get('answerKeys').filterProperty('column', columnNumber);

    // Validations
    var numberOfCells = procedure.get('rows').length;
    if (numberOfCells != studentInput.length) return [];

    // This is getting the appropriate value from the student input to compare
    function getStudentInput(indices, studentInput) {
      var arr = [];
      indices.forEach(function(i) {
        arr.push(studentInput[i]);
      });
      return arr;
    }

    answerKeys.forEach(function(answerKey) {
      keyMatches.push(answerKey);
      var key = answerKey.get('cellValues');
      var indices = answerKey.get('cells');
      var student = getStudentInput(indices, studentInput);
      var matchType = answerKey.get('match');
      // Everything up to this point is just getting the correct values to compare, so this is the method that really needs to change.
      // This bascially just says if it is not a match, then remove it from the returned answer keys
      if (matchType === "ALL") {
        if (CoreCircsim.compareStudentInputWithKey(key, true, student) === false) keyMatches.removeObject(answerKey);
      } else if(matchType === "ANY") {
        if (CoreCircsim.compareStudentInputWithKey(key, false, student) === false) keyMatches.removeObject(answerKey);
      } else {
          SC.error("CoreCircsim.evaluateProcedureSpecficErrors: Bad match type");
      }
    });

    return keyMatches;
  },

  // This returns true or false based on whether it's a match
  compareStudentInputWithKey: function(key, match, student) {
    var returnVal;
    if (match) {
      // match == true: match all of the conditions
      returnVal = true;
      for (var i = 0; i < key.length; i++) {
        var k = key[i];
        var s = student[i];
        if (k == 3) {
          if (SC.compare(0, s) === 0) {
            returnVal = false;
            break;
          }
        } else if (k == 4) {
          if (SC.compare(1, s) === 0) {
            returnVal = false;
            break;
          }
        } else if (k == 5) {
          if (SC.compare(2, s) === 0) {
            returnVal = false;
            break;
          }
        } else {
          if (SC.compare(k, s) !== 0) {
            returnVal = false;
            break;
          }
        }
      }
      return returnVal;
    } else {
        // match any of the conditions
      returnVal = false;
      for (var i = 0; i < key.length; i++) {
        var k = key[i];
        var s = student[i];
        if (k == 3) {
          if (SC.compare(0, s) !== 0) {
            returnVal = true;
            break;
          }
        } else if (k == 4) {
          if (SC.compare(1, s) !== 0) {
            returnVal = true;
            break;
          }
        } else if (k == 5) {
          if (SC.compare(2, s) !== 0) {
            returnVal = true;
            break;
          }
        } else {
          if (SC.compare(k, s) === 0) {
            returnVal = true;
            break;
          }
        }
      }
      return returnVal;
    }
  }
});

/* >>>>>>>>>> BEGIN source/core_grid.js */
/*globals CoreCircsim*/

SC.mixin(CoreCircsim, {
    createGrid : function(procedure) {
        var columns = procedure.get('columns');

        // This is a check to now create more cols/cells if the procedure has
        // already been created.
        if (columns.length() > 0) {
            return procedure;
        }

        procedure = this.createColumns(procedure);
        procedure = this.createCells(procedure);

        return procedure;
    },

    createColumns : function(procedure) {
        var headers = procedure.get('cols');

        headers.forEach(function(header) {
            var id = Math.random(Math.floor(Math.random() * 99999999));
            var col = CoreCircsim.store.createRecord(CoreCircsim.Column, {
                header : header
            }, id);
            procedure.get('columns').pushObject(col);

            var answerKeys = procedure.get('answerKeys');
            answerKeys.forEach(function(answerKey) {
                col.get('answerKeys').pushObject(answerKey);
            });
        });

        return procedure;
    },

    createCells : function(procedure) {
        var cols = procedure.get('columns');
        var rows = procedure.get('rows');

        cols.forEach(function(col) {
            for ( var i = 0; i < rows.length; i++) {
                var id = Math.random(Math.floor(Math.random() * 99999999));
                var cell = CoreCircsim.store.createRecord(CoreCircsim.Cell, {
                    isEnabled : NO
                }, id);
                col.get('cells').pushObject(cell);
            }
        });

        return procedure;
    },

    updateCell : function(cell) {
        var isEnabled = cell.get('isEnabled');
        if (!isEnabled)
            return;

        var val = cell.get('value'), newVal = "";
        switch (val) {
        case null:
            newVal = 0;
            break;
        case 0:
            newVal = 1;
            break;
        case 1:
            newVal = 2;
            break;
        case 2:
            newVal = 0;
            break;
        default:
            break;
        }
        cell.set('value', newVal);
    },

    updateHighlighting : function(cells, highlights) {
        if (highlights) {
            highlights.forEach(function(i) {
                cells.objectAt(i).set('isHighlighted', true);
            });
        } else {
            cells.forEach(function(cell) {
                cell.set('isHighlighted', false);
            });
        }
    },

    setCellsToCorrectValues : function(key, cells) {
        cells.forEach(function(cell, idx) {
            cell.set('correctAnswer', key[idx]);
        });

        return cells;
    },

    displayValues : function(cells) {
        cells.forEach(function(cell) {
            cell.set('displayValue', true);
        });
    },

    displayCorrectAnswers : function(cells) {
        cells.forEach(function(cell) {
            cell.set('displayCorrectAnswer', true);
        });
    },

    removeValues : function(cells) {
        cells.forEach(function(cell) {
            cell.set('displayValue', false);
        });
    },

    removeCorrectAnswers : function(cells) {
        cells.forEach(function(cell) {
            cell.set('displayCorrectAnswer', false);
        });
    },

    setPVToCorrect : function(procedure, cells) {
        var pvIdx = procedure.get('initialVariable');
        var pvDirection = procedure.get('initialVariableDirection');
        var pvText = procedure.get('rows')[pvIdx];
        cells.objectAt(pvIdx).set('value', pvDirection);
    },

    highlightCorrectRelationships : function(cells, indices) {
        indices.forEach(function(i) {
            cells.objectAt(i).set('highlightRECorrect', true);
            cells.objectAt(i).set('highlightREIncorrect', false);
        });
    },

    highlightIncorrectRelationships : function(cells, indices) {
        indices.forEach(function(i) {
            cells.objectAt(i).set('highlightRECorrect', false);
            cells.objectAt(i).set('highlightREIncorrect', true)
        });
    },

    removeREHighlights : function(cells) {
        cells.forEach(function(cell) {
            cell.set('highlightRECorrect', false);
            cell.set('highlightREIncorrect', false);
        });
    }
});

/* >>>>>>>>>> BEGIN source/core_loader.js */
SC.mixin(CoreCircsim, {

    /*
     * Loads the simulation procedure information into memory.
     * 
     * Procedure information is specified in XML files stored on the server. The
     * structure is as follows:
     * 
     * procedure_1/ procedure_1/answer_keys.xml procedure_1/procedure.xml
     * 
     * procedure_2/ procedure_2/answer_keys.xml procedure_2/procedure.xml
     * 
     * ...
     * 
     * The procedure directories must be named using the format "procedure_N"
     * where N is a number (no leading zeros). The numbers should be sequential
     * (i.e. do not skip). This function assumes directory names to be in this
     * format and reads the contents of each directory until it finds a
     * directory that does not exist. Thus, if you have directories numbered 1,
     * 2, 4, then directory 4 will not be read because the function did not find
     * directory 3.
     * 
     * The XML files are generated from a Microsoft Excel spreadsheet using the
     * "save as XML" option when saving.
     * 
     * The information read from the XML files are saved to memory using
     * SproutCore's datastore functionality.
     */
    populateProcedures : function() {

        var answerKeysFile = "answer_keys.xml";
        var procedureFile = "procedure.xml";
        var procedureDirBasename = "procedure_";

        var hasProcedures = true;
        var procedureNumber = 1;

        // used as a part of creating the ID for the procedure record
        var proceduresMultiplier = 1000;

        while (hasProcedures) {

            // the ID passed to the datastore when saving the procedure
            var procedureID = proceduresMultiplier * procedureNumber;

            /*
             * Step 1: Make sure the procedure directory exists.
             */

            if (window.XMLHttpRequest) {// code for IE7+, Firefox, Chrome,
                // Opera, Safari
                directoryRequest = new XMLHttpRequest();
            } else {// code for IE6, IE5
                directoryRequest = new ActiveXObject("Microsoft.XMLHTTP");
            }

            var procedureDirectory = procedureDirBasename + procedureNumber + "/";
	    var procedureExists = false;

            directoryRequest.open("GET", procedureDirectory, false);
            directoryRequest.send();
            SC.debug("Request status code is " + directoryRequest.status);

            if (directoryRequest.status == 403) {
                var fileToRetrieve = procedureDirectory + procedureFile;
                if (window.XMLHttpRequest) {// code for IE7+, Firefox, Chrome,
                    // Opera, Safari
                    fileRequest = new XMLHttpRequest();
                } else {// code for IE6, IE5
                    fileRequest = new ActiveXObject("Microsoft.XMLHTTP");
                }
                fileRequest.open("GET", fileToRetrieve, false);
                fileRequest.send();
                SC.debug("Request status code of file is " + fileRequest.status);
                if (fileRequest.status == 200) {
                    procedureExists = true;
                }
	    }
            else if (directoryRequest.status == 200) {
                procedureExists = true;
            }

            if (procedureExists === true) {

                /*
                 * Step 2: Read information from procedure.xml.
                 */

                // Retrieve procedure file
                var fileToRetrieve = procedureDirectory + procedureFile;
                if (window.XMLHttpRequest) {// code for IE7+, Firefox, Chrome,
                    // Opera, Safari
                    fileRequest = new XMLHttpRequest();
                } else {// code for IE6, IE5
                    fileRequest = new ActiveXObject("Microsoft.XMLHTTP");
                }

                fileRequest.open("GET", fileToRetrieve, false);
                fileRequest.send();
                if (fileRequest.status != 200) {
                    SC.error("Procedure file not found: " + fileToRetrieve);
                    break;
                }

                xmlDoc = fileRequest.responseXML;

                procedure = CoreCircsim.store.createRecord(CoreCircsim.Procedure, {
                    instructions : "Instructions go here.",
                    isComplete : false,
                    cols : [ "DR", "RR", "SS" ],
                    rows : [ "IS", "CVP", "SV", "HR", "CO", "Ra", "MAP" ],
                    relationshipEvaluations : [ {
                        equation : [ 4, 2, 3 ],
                        intro : "Before the simulation is run your predictions will be reviewed for logical consistency and for conformity to the relationship: CO=SVxHR. You will be asked to correct any errors. Please click Next to continue.",
                        errorMessage : "Your predictions do not agree with the relationship: CO = HR X SV. You need to correct your errors.  Click Next when you are finished.",
                        summaryCorrectMessage : "Great! Your predictions are consistent with the relationship: CO=SVxHR",
                        summaryIncorrectMessage : "Sorry, your predictions are still not consistent with the relationship: CO=SVxHR. However, at this time we will move on."
                    }, {
                        equation : [ 6, 4, 5 ],
                        intro : "Before the simulation is run your predictions will be reviewed for logical consistency and for conformity to the relationship: MAP = CO x TPR. You will be asked to correct any errors. Please click Next to continue.",
                        errorMessage : "Your predictions do not agree with the relationship: MAP = CO x TPR. You need to correct your errors.  Click Next when you are finished.",
                        summaryCorrectMessage : "Great! Your predictions are consistent with the relationship: MAP = CO x TPR",
                        summaryIncorrectMessage : "Sorry, your predictions are still not consistent with the relationship: MAP = CO x TPR. However, at this time we will move on."
                    } ]
                }, procedureID);

                // Loop through rows
                allRows = xmlDoc.getElementsByTagName("Row");

                cellOffset = 1;

                allCellsInRow = allRows[1].getElementsByTagName("Cell");
                procedure.set('title', allCellsInRow[0].childNodes[0].childNodes[0].nodeValue);
                procedure.set('introduction', allCellsInRow[1].childNodes[0].childNodes[0].nodeValue);
                procedure.set('initialVariable', parseInt(allCellsInRow[2].childNodes[0].childNodes[0].nodeValue, 10));
                procedure.set('initialVariableDirection', parseInt(allCellsInRow[3].childNodes[0].childNodes[0].nodeValue, 10));
                procedure.set('initialVariableSummary', allCellsInRow[4].childNodes[0].childNodes[0].nodeValue);
                procedure.set('procedureSummary', allCellsInRow[5].childNodes[0].childNodes[0].nodeValue);

                keyArray = allCellsInRow[6].childNodes[0].childNodes[0].nodeValue.split(',');
                for (i = 0; i < keyArray.length; ++i) {
                    keyArray[i] = parseInt(keyArray[i], 10);
                }
                procedure.set('key', keyArray);

                /*
                 * Step 3: Read in the answer keys from answer_keys.xml. These
                 * are specific responses to check for so that detailed
                 * commentary can be provided.
                 */

                // Retrieve answer keys
                fileToRetrieve = procedureDirectory + answerKeysFile;
                if (window.XMLHttpRequest) {// code for IE7+, Firefox, Chrome,
                    // Opera, Safari
                    fileRequest = new XMLHttpRequest();
                } else {// code for IE6, IE5
                    fileRequest = new ActiveXObject("Microsoft.XMLHTTP");
                }

                fileRequest.open("GET", fileToRetrieve, false);
                fileRequest.send();
                if (fileRequest.status != 200) {
                    SC.error("Answer keys file not found: " + fileToRetrieve);
                    break;
                }

                xmlDoc = fileRequest.responseXML;

                // Loop through rows
                allRows = xmlDoc.getElementsByTagName("Row");

                for (row = 1; row < allRows.length; ++row) {

                    var rowID = procedureID + row;

                    cellsToCheck = new Array();
                    comparisonValues = new Array();

                    // Loop through cells in row
                    allCellsInRow = allRows[row].getElementsByTagName("Cell");

                    answerKey = CoreCircsim.store.createRecord(CoreCircsim.AnswerKey, {}, procedureNumber * proceduresMultiplier + row);

                    /*
                     * The XML representation of the spreadsheet is compact.
                     * Empty cells are not included. This accounts for this
                     * using the ss:Index attribute of the cell (seen later on).
                     */
                    cellOffset = 1;

                    for (cell = 0; cell < allCellsInRow.length; ++cell) {

                        currentCell = allCellsInRow[cell];
                        actualIndex = currentCell.getAttribute("ss:Index");

                        if (null != actualIndex) {
                            cellOffset = actualIndex - cell;
                        }
                        actualIndex = cell + cellOffset - 1;
                        SC.debug("cell: " + cell + ", actual index: " + actualIndex);

                        if (0 == actualIndex) {
                            answerKey.set('category', allCellsInRow[cell].childNodes[0].childNodes[0].nodeValue);
                            SC.debug("Procedure " + procedureNumber + ", row " + row + ": category is " + answerKey.get('category'));
                        } else if (1 == actualIndex) {
                            answerKey.set('column', parseInt(allCellsInRow[cell].childNodes[0].childNodes[0].nodeValue, 10));
                            SC.debug("Procedure " + procedureNumber + ", row " + row + ": column is " + answerKey.get('column'));
                        } else if (2 == actualIndex) {
                            answerKey.set('comment', allCellsInRow[cell].childNodes[0].childNodes[0].nodeValue);
                            SC.debug("Procedure " + procedureNumber + ", row " + row + ": comment is " + answerKey.get('comment'));
                        } else if (3 == actualIndex) {
                            answerKey.set('isCorrect', allCellsInRow[cell].childNodes[0].childNodes[0].nodeValue);
                            SC.debug("Procedure " + procedureNumber + ", row " + row + ": isCorrect is " + answerKey.get('isCorrect'));
                        } else if (4 == actualIndex) {
                            answerKey.set('match', allCellsInRow[cell].childNodes[0].childNodes[0].nodeValue.toUpperCase());
                            SC.debug("Procedure " + procedureNumber + ", row " + row + ": match is " + answerKey.get('match'));
                        } else if (5 == actualIndex) {
                            highlightsArray = allCellsInRow[cell].childNodes[0].childNodes[0].nodeValue.split(',');
                            for (i = 0; i < highlightsArray.length; ++i) {
                                highlightsArray[i] = parseInt(highlightsArray[i], 10);
                            }
                            answerKey.set('highlights', highlightsArray);
                            SC.debug("Procedure " + procedureNumber + ", row " + row + ": highlights is " + answerKey.get('highlights'));
                        } else {
                            procedureTableCell = cell + cellOffset - 7;
                            cellsToCheck.push(procedureTableCell);
                            comparisonValues.push(parseInt(currentCell.childNodes[0].childNodes[0].nodeValue, 10));
                        }
                    }

                    answerKey.set('cells', cellsToCheck);
                    answerKey.set('cellValues', comparisonValues);

                    SC.debug("Procedure " + procedureNumber + ", row " + row + ": cells is " + answerKey.get('cells'));
                    SC.debug("Procedure " + procedureNumber + ", row " + row + ": cellValues is " + answerKey.get('cellValues'));

                    procedure.get('answerKeys').pushObject(answerKey);

                    CoreCircsim.store.commitRecord(rowID);
                    SC.debug("Pushed answer key to procedure");
                }

                CoreCircsim.store.commitRecord(procedureID);
                procedureNumber++;
            } else {
                SC.info("Procedure directory " + procedureDirectory + " does not exist. All procedures should be loaded now.")
                hasProcedures = false;
            }

        }

    }
});

/* >>>>>>>>>> BEGIN source/models/answer_key.js */
/*globals CoreCircsim*/

CoreCircsim.AnswerKey = SC.Record.extend({
  
  highlights: SC.Record.attr(Array),
  category: SC.Record.attr(String),
  isCorrect: SC.Record.attr(Boolean),
  match: SC.Record.attr(String),
  comment: SC.Record.attr(String),
  cells: SC.Record.attr(Array),
  cellValues: SC.Record.attr(Array),
  column: SC.Record.attr(Number),

  procedure: SC.Record.toOne('CoreCircsim.Procedure', {
    isMaster: NO
  })

});

/* >>>>>>>>>> BEGIN source/models/cell.js */
/*globals CoreCircsim*/

CoreCircsim.Cell = SC.Record.extend({
  value: SC.Record.attr(Number, {defaultValue: null}),
  isHighlighted: SC.Record.attr(Boolean),
  isEnabled: SC.Record.attr(Boolean),
  correctAnswer: SC.Record.attr(Number),
  displayCorrectAnswer: SC.Record.attr(Boolean),
  highlightRECorrect: SC.Record.attr(Boolean, {defaultValue: false}), 
  highlightREIncorrect: SC.Record.attr(Boolean, {defaultValue: false}),
  displayValue: SC.Record.attr(Boolean, {defaultValue: true}),
  
  column: SC.Record.toOne('CoreCircsim.Column', {
    isMaster: NO
  })
});

/* >>>>>>>>>> BEGIN source/models/column.js */
/*globals CoreCircsim*/

CoreCircsim.Column = SC.Record.extend({

  header: SC.Record.attr(String),

  cells: SC.Record.toMany('CoreCircsim.Cell', {
    isMaster: YES,
    inverse: 'column'
  }),

  procedure: SC.Record.toOne('CoreCircsim.Procedure', {
    isMaster: NO
  }),
  
  answerKeys: SC.Record.toMany('CoreCircsim.AnswerKey', {
    isMaster: YES,
    inverse: 'column'
  })
  

});

/* >>>>>>>>>> BEGIN source/models/procedure.js */
/*globals CoreCircsim*/

CoreCircsim.Procedure = SC.Record.extend({

  title: SC.Record.attr(String),
  introduction: SC.Record.attr(String),
  currentColumn: SC.Record.attr(Number),
  cols: SC.Record.attr(Array),
  rows: SC.Record.attr(Array),
  initialVariable: SC.Record.attr(Number),
  initialVariableDirection: SC.Record.attr(Number),
  
  key: SC.Record.attr(Array),
    
  remainingColumns: SC.Record.attr(Number, {
    defaultValue: 0
  }),
  isComplete: SC.Record.attr(Boolean, {
    defaultValue: false
  }),

  columns: SC.Record.toMany('CoreCircsim.Column', {
    isMaster: YES,
    inverse: 'procedure'
  }),
  
  answerKeys: SC.Record.toMany('CoreCircsim.AnswerKey', {
    isMaster: YES,
    inverse: 'procedure'
  })
  
  
  
    
});

